//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"fmt"
	"io"
	"io/fs"
	"os"
	"os/exec"
	"sort"
	"strings"
	"text/template"
)

type data struct {
	Type          string
	Name          string
	Imports       []string
	ImportsString string
}

func main() {
	types := map[string]data{
		"chan_canvasobject.go": {
			Type:    "fyne.CanvasObject",
			Name:    "CanvasObject",
			Imports: []string{"fyne.io/fyne/v2"},
		},
		"chan_func.go": {
			Type:    "func()",
			Name:    "Func",
			Imports: []string{},
		},
		"chan_interface.go": {
			Type:    "interface{}",
			Name:    "Interface",
			Imports: []string{},
		},
	}

	for fname, data := range types {
		data.Imports = append(data.Imports, "sync")
		data.ImportsString = formatImports(data.Imports)

		buf := &bytes.Buffer{}
		err := impl.Execute(buf, data)
		if err != nil {
			panic(fmt.Errorf("failed to generate unbounded channel for type %s: %v", data.Type, err))
		}

		code, err := formatter(buf.String())
		if err != nil {
			panic(fmt.Errorf("failed to format the generated code:\n%v", err))
		}

		os.WriteFile(fname, code.Bytes(), fs.ModePerm)
	}
}

// Have to reorder and group imports so that goimports static check would be OK with
// the generated file.
func formatImports(imports []string) string {
	if len(imports) == 0 {
		return ""
	} else if len(imports) == 1 {
		return fmt.Sprintf("import \"%s\"", imports[0])
	}

	importsString := "import (\n"

	var stdlibImports, localImports, otherImports []string
	isStdlibImport := func(s string) bool {
		return !strings.Contains(s, ".")
	}
	isLocalImport := func(s string) bool {
		return strings.HasPrefix(s, "fyne.io/fyne/")
	}

	for _, name := range imports {
		if isStdlibImport(name) {
			stdlibImports = append(stdlibImports, name)
		} else if isLocalImport(name) {
			localImports = append(localImports, name)
		} else {
			otherImports = append(otherImports, name)
		}
	}

	sort.Strings(stdlibImports)
	sort.Strings(localImports)
	sort.Strings(otherImports)

	for _, name := range stdlibImports {
		importsString += fmt.Sprintf("\t\"%s\"\n", name)
	}
	whitespaceAdded := false
	for _, name := range localImports {
		if len(stdlibImports) > 0 && !whitespaceAdded {
			importsString += "\n"
			whitespaceAdded = true
		}
		importsString += fmt.Sprintf("\t\"%s\"\n", name)
	}
	whitespaceAdded = false
	for _, name := range otherImports {
		if (len(stdlibImports)+len(localImports)) > 0 && !whitespaceAdded {
			importsString += "\n"
			whitespaceAdded = true
		}
		importsString += fmt.Sprintf("\t\"%s\"\n", name)
	}

	importsString += ")\n"

	return importsString
}

func formatter(src string) (*bytes.Buffer, error) {
	cmd := exec.Command("gofmt")

	var stdout bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	stdin, err := cmd.StdinPipe()
	if err != nil {
		return nil, err
	}

	io.WriteString(stdin, src)
	stdin.Close()

	if err := cmd.Run(); err != nil {
		return &stderr, err
	}

	return &stdout, nil
}

var impl = template.Must(template.New("async").Parse(`// Code generated by go run gen.go; DO NOT EDIT.

package async

{{.ImportsString}}

// Unbounded{{.Name}}Chan is a channel with an unbounded buffer for caching
// {{.Name}} objects.
type Unbounded{{.Name}}Chan struct {
	in, out chan {{.Type}}
	close   chan struct{}
	q       []{{.Type}}

	estimateLock sync.Mutex
	estimate     int // a number guaranteed to be <= len(ch.q) at all times
}

const estimate{{.Name}}Precision = 10

// NewUnbounded{{.Name}}Chan returns a unbounded channel with unlimited capacity.
func NewUnbounded{{.Name}}Chan() *Unbounded{{.Name}}Chan {
	ch := &Unbounded{{.Name}}Chan{
		// The size of {{.Name}} is less than 16 bytes, we use 16 to fit
		// a CPU cache line (L2, 256 Bytes), which may reduce cache misses.
		in:  make(chan {{.Type}}, 16),
		out: make(chan {{.Type}}, 16),
		close: make(chan struct{}),
	}
	go ch.processing()
	return ch
}

// In returns the send channel of the given channel, which can be used to
// send values to the channel.
func (ch *Unbounded{{.Name}}Chan) In() chan<- {{.Type}} { return ch.in }

// Out returns the receive channel of the given channel, which can be used
// to receive values from the channel.
func (ch *Unbounded{{.Name}}Chan) Out() <-chan {{.Type}} { return ch.out }

// Close closes the channel.
func (ch *Unbounded{{.Name}}Chan) Close() { ch.close <- struct{}{} }

func (ch *Unbounded{{.Name}}Chan) processing() {
	// This is a preallocation of the internal unbounded buffer.
	// The size is randomly picked. But if one changes the size, the
	// reallocation size at the subsequent for loop should also be
	// changed too. Furthermore, there is no memory leak since the
	// queue is garbage collected.
	ch.q = make([]{{.Type}}, 0, 1<<10)
	for {
		select {
		case e, ok := <-ch.in:
			if !ok {
				// We don't want the input channel be accidentally closed
				// via close() instead of Close(). If that happens, it is
				// a misuse, do a panic as warning.
				panic("async: misuse of unbounded channel, In() was closed")
			}
			ch.q = append(ch.q, e)
		case <-ch.close:
			ch.closed()
			return
		}
		for len(ch.q) > 0 {
			select {
			case ch.out <- ch.q[0]:
				ch.q[0] = nil // de-reference earlier to help GC
				if (len(ch.q)%estimate{{.Name}}Precision == 1) || (len(ch.q) <= estimate{{.Name}}Precision) {
					ch.estimateLock.Lock()
					ch.estimate = len(ch.q) - 1
					ch.estimateLock.Unlock()
				}
				ch.q = ch.q[1:]
			case e, ok := <-ch.in:
				if !ok {
					// We don't want the input channel be accidentally closed
					// via close() instead of Close(). If that happens, it is
					// a misuse, do a panic as warning.
					panic("async: misuse of unbounded channel, In() was closed")
				}
				ch.q = append(ch.q, e)
				if len(ch.q)%estimate{{.Name}}Precision == 0 || (len(ch.q) <= estimate{{.Name}}Precision) {
					ch.estimateLock.Lock()
					ch.estimate = len(ch.q)
					ch.estimateLock.Unlock()
				}
			case <-ch.close:
				ch.closed()
				return
			}
		}
		// If the remaining capacity is too small, we prefer to
		// reallocate the entire buffer.
		if cap(ch.q) < 1<<5 {
			ch.q = make([]{{.Type}}, 0, 1<<10)
		}
	}
}

// EstimatedLength returns the number guaranteed to be less than or equal to
// the number of items in the internal buffer ready to be consumed.
func (ch *Unbounded{{.Name}}Chan) EstimatedLength() int {
	ch.estimateLock.Lock()
	result := ch.estimate
	ch.estimateLock.Unlock()
	return result
}

func (ch *Unbounded{{.Name}}Chan) closed() {
	close(ch.in)
	for e := range ch.in {
		ch.q = append(ch.q, e)
	}
	for len(ch.q) > 0 {
		select {
		case ch.out <- ch.q[0]:
			ch.q[0] = nil // de-reference earlier to help GC
			ch.q = ch.q[1:]
		default:
		}
	}
	close(ch.out)
	close(ch.close)
}
`))

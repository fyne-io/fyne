//go:build ignore
// +build ignore

package main

import (
	"bytes"
	"fmt"
	"io"
	"io/fs"
	"os"
	"os/exec"
	"text/template"
)

type data struct {
	Type    string
	Name    string
	Imports string
}

func main() {
	types := map[string]data{
		"chan_canvasobject.go": data{
			Type:    "fyne.CanvasObject",
			Name:    "CanvasObject",
			Imports: `import "fyne.io/fyne/v2"`,
		},
		"chan_func.go": data{
			Type:    "func()",
			Name:    "Func",
			Imports: "",
		},
	}

	for fname, data := range types {
		buf := &bytes.Buffer{}
		err := impl.Execute(buf, data)
		if err != nil {
			panic(fmt.Errorf("failed to generate unbounded channel for type %s: %v", data.Type, err))
		}

		code, err := formatter(buf.String())
		if err != nil {
			panic(fmt.Errorf("failed to format the generated code:\n%v", err))
		}

		os.WriteFile(fname, code.Bytes(), fs.ModePerm)
	}
}

func formatter(src string) (*bytes.Buffer, error) {
	cmd := exec.Command("gofmt")

	var stdout bytes.Buffer
	var stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	stdin, err := cmd.StdinPipe()
	if err != nil {
		return nil, err
	}

	io.WriteString(stdin, src)
	stdin.Close()

	if err := cmd.Run(); err != nil {
		return &stderr, err
	}

	return &stdout, nil
}

var impl = template.Must(template.New("async").Parse(`// Code generated by go run gen.go; DO NOT EDIT.

package async

{{.Imports}}

// Unbounded{{.Name}}Chan is a channel with an unbounded buffer for caching
// {{.Name}} objects.
//
// Delicate dance: One must aware that an unbounded channel may lead
// to OOM when the consuming speed of the buffer is lower than the
// producing speed constantly. However, such a channel may be fairly
// used for event delivering if the consumer of the channel consumes
// the incoming forever. Especially, rendering and even processing tasks.
type Unbounded{{.Name}}Chan struct {
	in, out chan {{.Type}}
}

// NewUnbounded{{.Name}}Chan returns a unbounded channel with unlimited capacity.
func NewUnbounded{{.Name}}Chan() *Unbounded{{.Name}}Chan {
	ch := &Unbounded{{.Name}}Chan{
		// The size of {{.Name}} is less than 16-bit, we use 128 to fit
		// a CPU cache line (L2, 256 Bytes), which may reduce cache misses.
		in:  make(chan {{.Type}}, 128),
		out: make(chan {{.Type}}, 128),
	}
	go func() {
		// This is a preallocation of the internal unbounded buffer.
		// The size is randomly picked. But if one changes the size, the
		// reallocation size at the subsequent for loop should also be
		// changed too. Furthermore, there is no memory leak since the
		// queue is garbage collected.
		q := make([]{{.Type}}, 0, 1<<10)
		for {
			e, ok := <-ch.in
			if !ok {
				close(ch.out)
				return
			}
			q = append(q, e)
			for len(q) > 0 {
				select {
				case ch.out <- q[0]:
					q = q[1:]
				case e, ok := <-ch.in:
					if ok {
						q = append(q, e)
						break
					}
					for _, e := range q {
						ch.out <- e
					}
					close(ch.out)
					return
				}
			}
			// If the remaining capacity is too small, we prefer to
			// reallocate the entire buffer.
			if cap(q) < 1<<5 {
				q = make([]{{.Type}}, 0, 1<<10)
			}
		}
	}()
	return ch
}

// In returns a send-only channel that can be used to send values
// to the channel.
func (ch *Unbounded{{.Name}}Chan) In() chan<- {{.Type}} { return ch.in }

// Out returns a receive-only channel that can be used to receive
// values from the channel.
func (ch *Unbounded{{.Name}}Chan) Out() <-chan {{.Type}} { return ch.out }
`))

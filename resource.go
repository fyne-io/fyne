package fyne

import (
	"bytes"
	"encoding/hex"
	"encoding/xml"
	"fmt"
	"image/color"
	"io"
	"io/ioutil"
)

// Resource represents a single binary resource, such as an image or font.
// A resource has an identifying name and byte array content.
// The serialised path of a resource can be obtained which may result in a
// blocking filesystem write operation.
type Resource interface {
	Name() string
	Content() []byte
	AdoptIconColor() bool
}

// StaticResource is a bundled resource compiled into the application.
// These resources are normally generated by the fyne_bundle command included in
// the Fyne toolkit.
type StaticResource struct {
	StaticName           string
	StaticContent        []byte
	StaticAdoptIconColor bool
}

// Name returns the unique name of this resource, usually matching the file it
// was generated from.
func (r *StaticResource) Name() string {
	return r.StaticName
}

// Content returns the bytes of the bundled resource, no compression is applied
// but any compression on the resource is retained.
func (r *StaticResource) Content() []byte {
	return r.StaticContent
}

// AdoptIconColor returns a boolean indicating whether this Resource should be recolored to match the theme's icon color
func (r *StaticResource) AdoptIconColor() bool {
	return r.StaticAdoptIconColor
}

// NewStaticResource returns a new static resource object with the specified
// name and content. Creating a new static resource in memory results in
// sharable binary data that may be serialised to the location returned by
// CachePath().
func NewStaticResource(name string, content []byte, adoptIconColor bool) *StaticResource {
	return &StaticResource{
		StaticName:           name,
		StaticContent:        content,
		StaticAdoptIconColor: adoptIconColor,
	}
}

// DynamicResource is a bundled resource that will adapt its content to match the current theme settings.
type DynamicResource struct {
	BaseResource *StaticResource
}

// Name returns the unique name of this resource, usually matching the file it was generated from.
func (r *DynamicResource) Name() string {
	return r.BaseResource.StaticName
}

// Content returns the bytes of the bundled vector
func (r *DynamicResource) Content() []byte {
	rdr := bytes.NewReader(r.BaseResource.Content())
	clr := CurrentApp().Settings().Theme().IconColor()
	var s svg
	if err := s.replaceFillColor(rdr, clr); err != nil {
		LogError("could not replace fill color, falling back to static content:", err)
		return r.BaseResource.StaticContent
	}
	b, err := xml.Marshal(s)
	if err != nil {
		LogError("could not marshal svg, falling back to static content:", err)
		return r.BaseResource.StaticContent
	}
	return b
}

type svg struct {
	XMLName  xml.Name   `xml:"svg"`
	XMLNS    string     `xml:"xmlns,attr"`
	Width    string     `xml:"width,attr"`
	Height   string     `xml:"height,attr"`
	ViewBox  string     `xml:"viewBox,attr"`
	Paths    []*path    `xml:"path"`
	Rects    []*rect    `xml:"rect"`
	Polygons []*polygon `xml:"polygon"`
	Groups   []*group   `xml:"g"`
}

type path struct {
	XMLName xml.Name `xml:"path"`
	Fill    string   `xml:"fill,attr"`
	D       string   `xml:"d,attr"`
}

type rect struct {
	XMLName xml.Name `xml:"rect"`
	Fill    string   `xml:"fill,attr"`
	X       string   `xml:"x,attr"`
	Y       string   `xml:"y,attr"`
	Width   string   `xml:"width,attr"`
	Height  string   `xml:"height,attr"`
}

type polygon struct {
	XMLName xml.Name `xml:"polygon"`
	Fill    string   `xml:"fill,attr"`
	Points  string   `xml:"points,attr"`
}

type group struct {
	XMLName  xml.Name   `xml:"g"`
	Id       string     `xml:"id,attr"`
	Paths    []*path    `xml:"path"`
	Rects    []*rect    `xml:"rect"`
	Polygons []*polygon `xml:"polygon"`
}

func replacePathsFill(paths []*path, hexColor string) {
	for _, path := range paths {
		if path.Fill != "none" {
			path.Fill = hexColor
		}
	}
}

func replaceRectsFill(rects []*rect, hexColor string) {
	for _, rect := range rects {
		if rect.Fill != "none" {
			rect.Fill = hexColor
		}
	}
}

func replacePolygonsFill(polys []*polygon, hexColor string) {
	for _, poly := range polys {
		if poly.Fill != "none" {
			poly.Fill = hexColor
		}
	}
}

func replaceGroupObjectFill(groups []*group, hexColor string) {
	for _, grp := range groups {
		replacePathsFill(grp.Paths, hexColor)
		replaceRectsFill(grp.Rects, hexColor)
		replacePolygonsFill(grp.Polygons, hexColor)
	}
}

func (s *svg) replaceFillColor(reader io.Reader, color color.Color) error {
	bSlice, err := ioutil.ReadAll(reader)
	if err != nil {
		return err
	}

	if err := xml.Unmarshal(bSlice, &s); err != nil {
		return err
	}

	replacePathsFill(s.Paths, colorToHexString(color))
	replaceRectsFill(s.Rects, colorToHexString(color))
	replacePolygonsFill(s.Polygons, colorToHexString(color))
	replaceGroupObjectFill(s.Groups, colorToHexString(color))

	return nil
}

func colorToHexString(color color.Color) string {
	r, g, b, _ := color.RGBA()
	cBytes := []byte{byte(r), byte(g), byte(b)}
	return fmt.Sprintf("#%s", hex.EncodeToString(cBytes))
}
